'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

exports.load = load;
exports.validate = validate;

var _configValidationError = require('./errors/config-validation-error');

var _configValidationError2 = _interopRequireDefault(_configValidationError);

var _configNotFoundError = require('./errors/config-not-found-error');

var _configNotFoundError2 = _interopRequireDefault(_configNotFoundError);

var _lodash = require('lodash.get');

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var cwd = process.cwd();

function load() {

  return new Promise(function (resolve, reject) {
    var conf = void 0;

    try {
      conf = require(cwd + '/totally');
      resolve(conf);
    } catch (e) {
      if (e.code === 'MODULE_NOT_FOUND') {
        reject(new _configNotFoundError2.default());
      } else {
        reject(e);
      }
    }
  });
}

function validateConfig(conf) {
  if (!Array.isArray(conf)) {
    throw new _configValidationError2.default('totally.js must export an array');
  }
}

function validateItem(item, itemIndex) {

  if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) !== 'object') {
    throw new _configValidationError2.default('an item in your configuration is not an object', { itemIndex: itemIndex });
  }

  if (!(0, _lodash2.default)(item, 'filePath')) {
    throw new _configValidationError2.default('filePath must be defined for each item', { itemIndex: itemIndex });
  }

  if (typeof (0, _lodash2.default)(item, 'filePath') !== 'string') {
    throw new _configValidationError2.default('filePath must be a string', { itemIndex: itemIndex });
  }

  if (!(0, _lodash2.default)(item, 'endpoint')) {
    throw new _configValidationError2.default('endpoint must be defined for each item', { itemIndex: itemIndex });
  }

  if (typeof (0, _lodash2.default)(item, 'endpoint') !== 'string') {
    throw new _configValidationError2.default('endpoint must be a string', { itemIndex: itemIndex });
  }

  var handler = (0, _lodash2.default)(item, 'handler');

  if (handler && typeof handler !== 'function') {
    throw new _configValidationError2.default('handler must be a function', { itemIndex: itemIndex });
  }

  var excludeFromDiff = (0, _lodash2.default)(item, 'excludeFromDiff');

  if (excludeFromDiff && !(Array.isArray(excludeFromDiff) || typeof excludeFromDiff === 'string')) {
    throw new _configValidationError2.default('excludeFrom Diff must be a string or array of strings', { itemIndex: itemIndex });
  }

  if (Array.isArray(excludeFromDiff) && !excludeFromDiff.every(function (diff) {
    return typeof diff === 'string';
  })) {
    throw new _configValidationError2.default('excludeFromDiff must only contain strings', { itemIndex: itemIndex });
  }
}

function validate(conf) {

  return new Promise(function (resolve, reject) {
    try {
      validateConfig(conf);
      conf.forEach(validateItem);
      resolve(conf);
    } catch (e) {
      reject(e);
    }
  });
}

exports.default = { load: load, validate: validate };